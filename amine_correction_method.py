# -*- coding: utf-8 -*-
"""Preprocessing-Test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GR7UVa8s9XdRaOxZk51eqPj-3eP2Mjfy
"""

from PIL import Image
import numpy as np
import cv2
from google.colab.patches import cv2_imshow

from google.colab import drive

drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
#%cd '/content/drive/MyDrive/RoboSub 2022/'
# %cd '/content/drive/MyDrive/RoboSub 2020/'

# Commented out IPython magic to ensure Python compatibility.
#%cd '/content/drive/MyDrive/RoboSub 2022/CS/CV Footage/Pool Test 9-18-21/gate_far_rotate_260in'
# %cd '/content/drive/MyDrive/Projects/RoboSub 2020/CS/Buoys/output2_frames'

image = cv2.imread('frame216.jpg') #Choose any image

cv2_imshow(image)

#The below is simplified, the original research paper (http://www.lsis.org/rov3d/article/art_AmineRhone2012.html) uses the 4th & 96th percentiles.

blue_min = np.percentile(image[:, :, 0], 4)
blue_max = np.percentile(image[:, :, 0], 96)
green_min = np.percentile(image[:, :, 1], 4)
green_max = np.percentile(image[:, :, 1], 96)
red_min = np.percentile(image[:, :, 2], 4)
red_max = np.percentile(image[:, :, 2], 96)

image = image.astype(np.int64) #To avoid overflow issues
blue_min

image[:, :, 0] = (255*(image[:, :, 0] - blue_min))/(blue_max-blue_min)
image[:, :, 1] = (255*(image[:, :, 1] - green_min))/(green_max-green_min)
image[:, :, 2] = (255*(image[:, :, 2] - red_min))/(red_max-red_min)

image

cv2_imshow(image)